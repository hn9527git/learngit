三次握手和四次挥手过程·························https://blog.csdn.net/qq_38950316/article/details/81087809
为什么需要三次握手和四次挥手
为什么要有TIME_WAIT这个状态？
	假设最终的ACK丢失，主机2将重发FIN，主机1必须维护TCP状态信息以便可以重发最终的ACK，
	否则会发送RST，结果主机2认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，
	主机1必须进入 TIME_WAIT 状态，因为主机1可能面 临重发最终ACK的情形。
冒泡排序----稳定------------------------https://www.cnblogs.com/hokky/p/8529042.html
选择排序----不稳定
插入排序----稳定
希尔排序----不稳定
快速排序----不稳定
归并排序----稳定
基数排序----稳定
设计模式：
	单例--------------------------------https://www.cnblogs.com/hokky/p/8529042.html
	简单工厂----------------------------https://www.cnblogs.com/jostree/p/4251756.html
模态和非模态
纯虚函数
死锁
	原因：互斥性、持有、不可剥夺、环形等待
	解决：预防，结束返错，设置超时结束
重载、覆盖、重定义
socket过程
数组和链表的区别
多态机制
new delete和malloc free区别
	1）malloc对开辟的空间大小严格指定，而new只需要对象名
	2）new为对象分配空间时，调用对象的构造函数，delete调用对象的析构函数
既然有了malloc/free，C++中为什么还需要new/delete呢？
	因为malloc/free是库函数而不是运算符，不能把执行构造函数和析构函数的功能强加于malloc/free
函数和运算符的区别：
	运算符本质上也是函数，只是运算符需要编译器进一步解释，函数是直接调用
虚函数机制
生成可执行文件的过程 预处理-编译-汇编-链接
进程间通信方式
epoll和select函数的区别
STL:
	包括容器和算法
#define和const、typdef的区别
	define预处理指令
	typdef编译时处理
堆和栈的区别
	1）栈 stack 存放函数的参数值、局部变量，由编译器自动分配释放
	堆heap，是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收
	2）因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片
	3）堆的生长空间向上，地址越大，栈的生长空间向下，地址越小
内存管理：
	栈：存放函数的参数和局部变量，由编译器自动分配和释放
	堆：由malloc分配的内存，free释放
内存五大区：
	堆栈
	全局区（静态区）--初始化和未初始化分开放
	文字常量区：常量存在这里
	程序代码区：二进制代码只读
内存泄漏以及解决办法
	动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。
	方法：malloc/free要配套，对指针赋值的时候应该注意被赋值的指针是否需要释放；使用的时候记得指针的长度，防止越界
深拷贝和浅拷贝：
	有没有重新分配资源
四种强制转换：
	static_cast:编译器静态类型检查
	dynamic_cast:运行时检查RTTI 基类引用|指针转换为派生类指针|引用
	const_cast:去除const属性
	reinterpret_cast:为了将一种数据结构转换为另一种数据结构
extern "C"
	指示编译器下边的代码按照C语言的方式进行编译
volatile
	指定编译器不做优化，每次到内存中取数据，而不是寄存器中
野指针：
	不是NULL指针，是未初始化或未清0的指针
	成因：
		指针变量没有初始化
		指针指向的内存被释放了，但是指针没有置为NULL
		指针超过了变量的安全范围 b[10],(b+11)
栈溢出以及解决办法
	局部变量太多或太大，递归太深
	可以加个static变成静态变量，或是申请动态空间
进程和线程的区别以及为什么要有进程
	https://www.cnblogs.com/zhuzhu2016/p/5804875.html
	线程进程的区别体现在4个方面：
	第一：因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，
		建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，
		而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，
		比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，
		也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，
		而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。
	第二：体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，
		消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。
	第三：体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，
		不同的线程运行于不同的CPU上。
	第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，
		使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，
		所以线程对程序结构的改善有很大帮助。
进程与线程的选择取决以下几点：
	1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。
	2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应
	3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；
	4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；
	5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。
进程间通信方式：
	管道、信号量、消息队列、共享内存、套接字
线程通信方式：
	全局变量、消息机制
-----------------------------------------数据库--------------------------------------------------------------------
事务ACID：
	原子性、一致性、隔离性、持久性
死锁：
	多个事务互相想访问对方的锁定的资源
三范式：
	表中字段不能再分
	满足第一条的情况下表中的非主键字段都依赖于主键字段
	满足第二条的情况下非主键字段必须不传递依赖于主键字段
级联删除|级联更新
	on delete cascade;on update cascade;
什么是游标
	是一种从包括多条数据记录的结果集中每次提取一条记录进行处理的机制
	使用步骤：
	1.定义游标 declare cursor name for select 查询语句 [for [readonly|update]];
	2.打开游标：open cursor
	3.操作数据：fetch ...... current of cursor；
存储过程的优缺点
	1.预编译过的，执行效率高2.存在数据库中，直接调用，减少网络通讯
	3.安全性高，需要权限4.可重复使用
	缺点：移植性差
存储过程与函数的区别
	存储过程实现的过程要复杂一些,而函数的针对性较强;
	存储过程可以有多个返回值,而自定义函数只有一个返回值;
	存储过程一般独立的来执行,而函数往往是作为其他SQL语句的一部分来使用;
存储过程
	delimiter //
	CREATE PROCEDURE proc ()
	BEGIN
    SELECT * FROM student;
	END//
自定义函数
	CREATE FUNCTION NameByZip() RETURNS CHAR(50)
	RETURN (select studentPhone from student where studentName = 'JAMES');
MVCC、以及优点和不足
	MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。
	缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。
索引的优缺点
视图的优缺点
	视图：虚拟表，具有和物理表相同的功能
主键和外键的区别
	主键在本表中是唯一的、不可唯空的，外键可以重复可以为空；
	外键和另一张表的主键关联，不能创建对应表中不存在的外键。
UNION和UNION ALL的区别
varchar2和varchar的区别
MySQL和Oracle的区别
	1.库函数不同
	2.Oracle是用表空间来管理的，MySQL不是
	3.显示当前表用户改变连接用户显示当前连接用户执行外部脚本不同
	4.分页查询时，MySQL用limit，Oracle用rownum
行转列，列转行
什么是PL/SQL？
truncate与delete的区别
	前者通过释放存储数据的数据页来删除，并且只在日志中记录页的释放
	后者每次删除一行，并且记录，耗费的资源多
	truncate table:删除内容不删除定义、释放空间
	delete table:删除内容不删除定义、不释放空间
	drop table:删除内容和定义、释放空间
oracle闪回技术
修改表结构SQL
	alter table name [add | modify | drop]
oracle创建约束
	constraint
oracle序列
	sequence:-----------------------https://blog.csdn.net/hu_dongyang/article/details/79039737


---------------------Linux--------------------------------------------------------------------
ls	cd	mv	mkdir	at	rmdir	rm	touch	locate	ps	jobs	kill	fd	bg
pwd	cp	cat more	less	reboot	poweroff	ping	grep	mount	tar	ln
chown	chmod	useradd	passwd	whereis	find	wget	df	du		
---------------------TCP/IP-------------------------------------------------------------------
TimeWait的作用：
	1.防止上一次连接中的包，迷路后重新出现，影响新连接
	（经过2MSL后，上一次连接中所有的重复包都会消失）
	2.可靠的关闭TCP连接
	在主动关闭方发送的最后一个ack(fin) ，有可能丢失，这时被动方会重新发
	fin, 如果这时主动方处于CLOSED 状态 ，就会响应rst(异常关闭连接) 而不是ack。所以
	主动方要处于TIME_WAIT 状态，而不能是CLOSED 。
	TIME_WAIT 并不会占用很大资源的，除非受到攻击。
	还有，如果一方send 或recv 超时，就会直接进入CLOSED 状态
















	