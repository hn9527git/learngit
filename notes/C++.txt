重写（覆盖）override
	override是重写（覆盖）了一个方法，以实现不同的功能。一般用于子类在继承父类时，重写（覆盖）
		父类中的方法。函数特征相同，但是具体实现不同。
	重写需要注意：
		被重写的函数不能是static的，必须是virtual的
		重写函数必须有相同的类型，名称和参数列表
		重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public、protect也是可以的
重载overload
	overload是重载，一般是在一个类实现若干重载的方法，
	这些方法的名称相同而参数形式不同。但是不能靠返回类型来判断。
	重载需要注意：
    		位于同一个作用域中
    		函数的名字必须相同
    		形参列表不同
		基于成员函数是否为const，也可以重载
    	若一个重载版本的函数面前有virtual修饰，则表示他是虚函数，但他也是属于重载的一个版本
    		不同的构造函数(无参构造、有参构造、拷贝构造）是重载的应用
重定义redefining
	派生类对基类的成员函数重新定义，即派生类定义了某个函数，该函数的名字与基类中函数名字一样。
	重定义也叫做隐藏，子类重定义父类中有相同名称的非虚函数（参数可以不同）。如果一个类，
	存在和父类相同的函数，那么这个类将会覆盖其父类的方法，除非你在调用的时候，强制转换为父类类型，
		否则试图对子类和父类做类似重载的调用时不能成功的。
	重定义需要注意：
    		不在同一个作用域（分别位于基类、派生类）
    	函数的名字必须相同
    	对函数的返回值、形参列表无要求
    	若派生类定义该函数与基类的成员函数完全一样（返回值、形参列表均相同），且基类的该函数为virtual，
		则属于派生类重写基类的虚函数
    	若重新定义了基类中的一个重载函数，则在派生类中，基类中该名字函数（即其他所有重载版本）
		都会被自动隐藏，包括同名的虚函数
多态polymorphism
　　多态的概念比较复杂，一种不严谨的说法是：继承是子类使用父类的方法，而多态是父类使用子类的方法。
　　一般我们使用多态是为了避免在父类里大量重载引起代码臃肿且难于维护。
　　多态分为两类：静态多态性和动态多态性，以前学过的函数重载和运算符重载实现的多态性属于静态多态性，
	在程序编译时系统就能决定调用哪个函数，因此静态多态性又称为编译时的多态性。静态多态性是通过函数的重载实现的。
	动态多态性是在程序运行过程中才动态地确定操作所针对的对象。它又称运行时的多态性。动态多态性是通过虚函数实现的。

动态绑定：
	只有通过基类的引用或指针调用虚函数(传给基类的引用或指针参数)，才会发生动态绑定：即运行时绑定
常量成员函数：
	double avg_price() const;
	const 成员不能改变其所操作的对象的数据成员。const 必须同时出现在声
		明和定义中，若只出现在其中一处，就会出现一个编译时错误。
成员函数重载
	只能重载本类的其他成员函数。类的成员函数与普通的非成员函数以及在其他类中声明的函数不相关，
		也不能重载它们。
不完整类型：
	在声明之后，定义之前，是一个不完整类型，不能定义该类型的的对象，只能定义指向该类型的指针以及引用，
		或者用于声明使用该类型作为形参类型或返回类型的函数；例如定义链表类时或单例类；
this指针：
	在普通非CONST成员函数中，是一个指向类类型的const指针，在const成员函数中是一个指向
		const类类型对象的const指针；
可变数据成员：
	mutable：甚至const成员也可以修改
大小端：
	大端模式，是指数据的高字节保存在内存的低地址中，
		而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作
		字符串顺序处理：地址由小向大增加，而数据从高位往低位放；
	小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
		这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。
类成员作用域：
	不仅要考虑在本类<定义>之前的全局作用域中的[声明]，而且要考虑在成员函数<定义>之前出现的全局作用域[声明]。
初始化：
	在局部作用域中内置类型成员不被初始化，在全局作用域中他们被初始化为0；
初始化列表：
	没有默认构造函数的类类型的成员，以及const或引用类型的成员<只能初始化，不能复制>，
	不管是哪种类型，都必须在构造函数初始化列表中进行初始化;
初始化次序：
	就是定义成员的次序，不是初始化列表中的次序。
显式初始化：==不建议
	对于没有定义构造函数并且其全体数据均为public的类，可以采用与初始化数组元素相同的方式初始化
	其成员。
explicit:
	抑制由构造函数定义的隐式转换；只能用在类内部的构造函数声明上。外部定义时不再重复它。
	除非有明显理由要定义隐式转换，否则单形参构造函数应该定义为explicit，若有转换需要，还可以
	显式使用构造函数来转换。
静态成员：
	外部定义时，无需重复指定static保留字，该保留字只出现在声明处；
	static函数没有this指针；
		因为static成员函数是类的组成部分但不是任何对象的组成部分，没有this指针(const修饰this)，所以也不能被声明为const；，
		也不能被声明为虚函数；
	static数据成员必须在类定义体的外部定义正好一次；他不是通过类构造函数进行初始化，
		而应该在定义时进行初始化；
		-- 类的数据成员不能在类定义体中初始化，例外：只要初始化式是一个常量表达式，
		-- 整形const static数据成员就可以在类的定义体中进行初始化，const static数据成员
		-- 在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义，
			若在类内部提供初始化式时，成员的定义不必再指定初始值；
		-- const static数据成员的类型可以是该成员所属的类类型。
		-- const static数据成员可用作默认实参
复制构造函数：
	具有单个形参，该形参(常用const修饰)是对该类类型的引用。
	・显式使用：当定义一个新对象并用一个同类型的对象对它进行初始化时。
	・隐式使用：当将该类型的对象传递给函数或函数返回该对象类型的对象时。
	直接初始化：将初始化式放在圆括号中。-》直接调用实参匹配的构造函数。
	复制初始化：使用=符号。-》创建临时对象――》复制到正在创建的对象
	-- 型参与返回值：为类类型时，使用复制构造函数进行复制
	-- 初始化容器元素：-》默认构造创建临时值-》复制构造复制到每一个元素
	-- 数组元素：若没有提供类类型的元素初始化，则默认构造初始化每个元素。
		若使用花括号初始化列表，则先创建后复制。
	禁止复制：将复制构造函数声明为private，类的友元和成员仍可复制，声明但不定义则绝不能复制。
	若定义了复制构造函数，也必须定义默认构造函数
赋值操作符：
	重载operate=函数，可以对赋值进行定义。
	-- 为类成员时，第一个操作数隐式绑定到this指针，右操作数一般为const引用传递。
	-- 返回值一般为类引用。
	复制构造函数和赋值操作符应一起出现。
析构函数：
	逆序撤销每个非static成员。
	即使我们编写了自己的析构函数，合成析构函数仍然运行。
	动态分配的对象只有在指向该对象的指针被删除时才撤销。
	当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的
	-- 指针或实际对象超出作用域时，才会运行析构函数。
	--容器中的对象逆序析构。
	三法则:如果类需要析构函数，则应该也需要复制构造函数和赋值操作符。
指针成员：
	复制指针时只复制指针中的地址，而不会复制指针指向的对象。
	管理指针常用的三种方法：
	1.指针成员采取常规指针性行为。这样的类具有指针的所有缺陷但无需特殊的复制控制。
	2.类可以实现所谓的智能指针行为。所指对象共享，但类能够防止悬垂指针。
	3.类采取值型行为。指针所指对象唯一，由每个类对象独立管理。复制时得到新副本，例如String类。
重载操作符：
	必须具有至少一个类类型或枚举类型的操作数。
	除了函数调用操作符operator()之外，重载操作符时使用默认实参是非法的。
	复合赋值(+=)返回对左操作数的引用，加操作符返回一个对象(为与内置操作符保持一致)。
	赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）等操作符必
	-- 须定义为成员，将这些操作符定义为非成员函数将在编译时标记为错误。
	? 像赋值一样，复合赋值操作符通常应定义为类的成员，与赋值不同的是，
	-- 不一定非得这样做， 如果定义非成员复合赋值操作符， 不会出现编译错误。
	? 改变对象状态或与给定类型紧密联系的其他一些操作符，如自增、自减和
	-- 解引用，通常就定义为类成员。
	? 对称的操作符，如算术操作符、相等操作符、关系操作符和位操作符，最
	-- 好定义为普通非成员函数。
	输出操作符不应该输出换行符。
	IO操作符必须为非成员函数：
		否则，左操作数只能是该类类型的对象，例：item<<cout;
		通常设置为友元。
	要输出的参数常设置为const引用。
	要输入的参数必须为非const，因为要读到该对象中。
		输入操作符必须处理错误和文件结束的可能性。if(cin) .. else 复位(默认构造)；
	赋值操作符可以重载，必须定义为成员函数，必须返回对*this的引用。	
	下标操作符定义时，一般需要两个版本：一个为非const成员并返回引用，一个为const成员返回
		const引用。
	自增/自减运算符：
		后缀式操作符函数接受一个额外的int型形参。
	函数调用操作符：
		boo operator(const string&s){return s.size()>=this->size}
		必须声明为成员函数。可重载。定义此的对象称为函数对象。
		函数对象的函数适配器：
			绑定器：将一个操作数绑定给定值而将二元函数对象转换为一元函数对象。
				bind1st和bind2nd：例：count_if(v.begin(),v.end(),
										bind2nd(less_equal<int>(),10);
			求反器：将谓词函数对象的真值求反。
				not1和not2：not1将一元函数对象的真值求反，not2将二元函数对象的真值求反。
				例：count_if(v.begin(),v.end(),
								not1(bind2nd(less_equal<int>(),10);
类类型转换：
	转换操作符：
		operator type() [const];//常为const成员
		必须为成员函数，不能指定返回类型，形参表必须为空。必须显式返回一个指定类型的值。
		只能应用一个类类型转换。
面向对象基本概念：数据抽象、继承、动态绑定
	虚函数：基类希望派生类重写的函数应定义为virtual，希望被继承的函数不能被定义为虚函数。
			非static成员函数。
			派生类必须对想要重定义的每个继承成员进行声明。
			声明必须与基类中的定义方式完全匹配，一个例外：返回对基类的引用或指针的虚函数，
				派生类中的虚函数可以返回基类函数所返回类型的派生类的引用或指针。
			加上域操作符可以强制调用虚函数的特定版本。
			派生类虚函数调用基类版本时，必须显式使用作用域操作符，否则，
				函数调用会在运行时确定并且是一个自身调用，导致无穷递归。
	动态绑定：使用继承层次中的任意对象，运行时指定，通过基类的引用或指针调用虚函数时发生。
			使用条件：1.只有虚函数成员才能进行动态绑定。
					2.必须通过基类类型的引用或指针进行函数调用。	
	protected成员：派生类只能通过派生类对象访问其基类的protected成员，派生类对
			其基类类型对象的protected成员没有特殊访问权限。
	派生类可以进一步限制基类的访问权限，但不能放松权限，无论什么访问标号，直接派生类
		对基类成员有相同的访问权限。派生类访问标号控制派生类的用户对从基类继承而来
		的成员的访问。
	友元关系不能继承。
转换与继承：
	转换要考虑派生列表中的访问标号。
	派生类对象转换为基类类型的引用：
		派生类对象的地址可以对基类类型的指针进行赋值或者初始化。
		可以使用派生类类型的引用或对象初始化基类类型的引用。
	派生类对象对基类对象进行初始化或赋值：
		将派生类传给希望接受基类类型对象的函数时，派生类的基类部分被复制到形参。
派生类构造函数：
	合成的派生类默认构造函数：
		1.调用基类的默认构造函数，初始化基类部分
		2.用常规变量初始化派生类部分，即未初始化。
	派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继
		承成员。相反派生类构造函数通过将基类包含在构造函数初始化列表中来间接初
		始化继承成员。
继承与复制：
	只含有类类型或内置类型数据成员、不含指针的类一般可以使用合成操作，
	具有指针成员的类一般需要定义自己的复制控制来管理这些成员。
	如果派生类定义了自己的复制构造函数，该复制构造函数一般显式使用基类复制构造
		函数初始化对象的基类部分。
	派生类赋值操作符同上：
		且赋值操作符必须防止自身复制：if(this!=&rhs){再操作};
	派生类析构函数;
		不负责撤销基类部分的成员，编译器显式调用派生类对象基类部分的析构函数。
		首先运行派生类析构函数，再运行基类析构函数。
虚析构函数：
	处理继承层次中的对象时，指针的静态类型可能与被删除对象的动态
		类型不同，可能会删除实际指向派生类对象的基类类型指针。
		解释:如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象
			实际是派生类类型，则没有定义该行为。所以析构函数必须是虚函数。
			例：class A;class B:public A; A * p=new B();
构造函数和析构函数中的虚函数问题：
	派生类构造过程中和派生类析构过程中，对象是不完整的。编译器将对象的类型视为
		在此期间发生了变化，将派生类对象当作基类类型对象对待。
		如果在析构函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数
			自身类型定义的版本。
继承与类作用域：
	如果不能在派生类作用域中确定名字，就在外围基类作用域中查找改名字的定义。
	名字查找在编译时发生。
	基类类型的指针引用或对象只能访问对象的基类部分。或派生类的虚函数（run time）
	与基类成员同名的派生类成员将屏蔽对基类成员的直接访问。可加作用域符号访问
	如果派生类重定义了重载成员，则通过派生类只能访问派生类中重定义的那些成员。
	如果派生类想通过自身类型使用的重载版本，则派生类必须要么重定义所有重载版本，要么
		一个也不定义。可以使用using声明将函数的所有重载实例加到派生类的作用域。
		然后只需要重定义本类型确实需要的重载版本即可，其他版本使用继承的定义。
纯虚函数：
	在函数形参表后面写上 =0 以指定纯虚函数
	该函数为后代类型提供了可以覆盖的接口，但这个类中绝对不会调用，
		最重要的是用户不能创建含有纯虚函数的类（抽象基类）的对象。
句柄类：定义包装
	句柄类存储和管理基类指针，指针所指对象的类型可以变化，它既可以指向基类类型对象又可以
		指向派生类对象。用户通过句柄类访问继承层次的操作，因为句柄类使用指针执行操作，
		虚成员的行为将在运行时根据句柄实际绑定的类型而变化，因此，句柄类的用户可以获
		得动态行为但无需操心指针的管理。
	像对任何保存指针的类一样，必须确定对复制控制做些什么。句柄类通常表现得像一个智能指针
		或者像一个值。
	句柄类决定句柄接口屏蔽还是不屏蔽继承层次。
模板：
	定义模板函数:template<typename T> [inline] T min(const T&,const T&);
	定义类模板：template<typename T> class 类名{};
	同一模板的声明和定义中，模板形参的名字不必相同。
	每个非类型形参前面必须带上类型名字。<typename T,L>//error
异常处理：
	异常类似于将实参传递给函数的方式抛出和捕获。可以传递给非引用形参的(意味着可以复制)
		不存在数组或函数类型的异常。相反，抛出一个数组，转换为指向数组首元素的指针，
		抛出一个函数，转换为指向该函数的指针。
	一般而言，在处理异常的时候，抛出异常的块中的局部存储不存在了。
		因为在处理异常的时候会释放局部存储，所以被抛出的对象就不能再局部存
		储，而是用 throw 表达式初始化一个称为异常对象的特殊对象。异常对象由编
		译器管理，而且保证驻留在可能被激活的任意 catch 都可以访问的空间。这个
		对象由 throw 创建，并被初始化为被抛出的表达式的副本。异常对象将传给对
		应的 catch，并且在完全处理了异常之后撤销。
	抛出指针通常是个坏主意：这要求在对应处理代码存在的任意地方存在指针所指向的对象。
栈展开：
	抛出异常--》暂停函数--》查找匹配的catch子句--》找不到--》调用函数退出--》继续在调用
		该函数的函数中查找。(嵌套函数调用链)。如果最终未找到匹配的catch，调用terminate函数。
	栈展开期间，提早退出包含throw的函数和调用链中可能的其他函数，编译器保证适当地
		撤销或析构局部对象。
	如果一个块直接分配资源，而且在释放资源之前发生异常，在栈展开期间将不会释放该资源。
	重新抛出异常：throw;
		单个catch不能完全处理一个异常时，通过重新抛出将异常传递给函数调用链中更上层的
		函数。
构造函数与函数测试块：
	为了处理来自构造函数初始化式的异常，必须将构造函数编写为函数try块：
	template<class T> H<T>::H(T *p)
	try:ptr(p),use(new size_t(1)){}
	catch(const std::bad_alloc &e)
	{h_out_of_memory(e);}
标准异常类层次：
						exception
	---------------------------------------------------------
	|	            |                  |                     |
bad_cast        runtime_error       logic_error          bad_alloc
			--------------------  ---------------------		
			1.overflow_error       1.domain_error
			2.underflow_error      2.invalid_argument
			3.range_error		   3.out_of_range
								   4.length_error
auto_ptr类：
	只能用于管理从new返回的一个对象，他不能管理动态分配的数组。
命名空间：
	可以在全局作用域或其他作用域内部定义，但不能在函数或类内部定义。
	命名空间作用域不能以分号结束。
	命名空间是累积的，可以分散到多个文件中。
	函数名完全限定，则处于命名空间的作用中，形参和函数体可以直接引用作用域内的成员。
	未命名的命名空间定义局部于特定文件，不跨越多个文本文件。
		可以不连续，不能使用域操作符引用，直接使用，如果在最外层作用域中定义，则未命名
		空间中的名字必须与全局作用域中定义的名字不同。
		如果头文件定义了未命名的命名空间，则每个包含该头文件的文件中，该空间定义不同的实体
	using声明：
		在声明作用域内可直接引用命名空间的成员
多重继承下成员X：
	如果在每个路径中X表示同一虚基类成员，则没有二义性，因为共享该成员的单个实例。
	如果在某个路径中X是虚基类的成员，而在另一路径中X是后代派生类的成员，也没有二义性，
		因为特定派生类实例的优先级高于共享虚基类实例
	如果沿每个继承路径X表示后代派生类的不同成员，则该成员的直接访问是二义性的。
	解决二义性可以在本类中设计覆盖实例。
虚基类的构造：必然是首先构造虚基类
			ZOO
		/         \
	  BEAR     RACOON
		\          /
		   PANDA
	由最底层的派生类PANDA直接控制虚基类ZOO的构造。
	然后构造中间派生类BEAR，忽略中间派生类BEAR用于构造虚基类的初始化列表的初始化式
	然后构造RACOON,再次忽略ZOO的初始化式
	最后构造PANDA部分。
优化内存分配：
	new基于每个对象分配内存的事实可能会对某些类强加不可接受的运行时开销，可以通过预先
		分配用于创建新对象的内存，需要时在预先分配的内存中构造每个新对象。
分配和释放未构造的原始内存
	1.allocator类：
		提供可感知类型的内存分配，这个类支持一个抽象接口，以分配内存并随后使用该内存保存对象
	2.标准库中的operator new和operator delete，他们分配和释放需要额定大小的原始的未类型化的内存
在原始内存中构造和撤销对象：
	1.allocator类提供construct和destroy成员，前者在未构造内存中初始化对象，后者在对象上运行
		适当的析构函数
	2.定位new表达式接受指向未构造内存的指针，并在该空间中初始化一个对象或一个数组
	3.可以直接调用对象的析构函数来撤销对象，析构函数不是放对象所在的内存
	4.算法uninitialized_file和uninitialized_copy像fill和copy算法一样执行，除了他们目的地构造对象
		而不是给对象赋值
operator new：库函数
	string * sp=new string("buzhidao");
	1.调用operator new的标准库函数，分配足够的内存-》
	2.运行构造函数，初始化-》
	3.返回该对象指针
operator delete：库函数
	delete sp;
	1.对sp指向的对象运行适当的析构函数
	2.调用operator delete标准库函数，释放该对象所用内存
定位new：
	接受指向已分配但未构造内存的指针，并在该内存中初始化一个对象
	new (p) T(t);
new表达式:
	调用operator new函数分配内存
	优化new和delete的行为时，只需要定义operator new和operator delete的新版本
自由列表：
	释放元素时，将内存放回预先分配的块中，而不是返回给系统
	
	
	
	
	
	
	
------------------ERROR------------------------------------------------------------------
全局变量重定义或是多次定义的：
	只要定义时尽量在.cpp文件中进行，而不要在.h文件中定义，在.h文件中用extern关键字声明，
		否则可能会引起重复定义。
	
	
	


















