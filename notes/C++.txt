重写（覆盖）override
	override是重写（覆盖）了一个方法，以实现不同的功能。一般用于子类在继承父类时，重写（覆盖）
		父类中的方法。函数特征相同，但是具体实现不同。
	重写需要注意：
		被重写的函数不能是static的，必须是virtual的
		重写函数必须有相同的类型，名称和参数列表
		重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public、protect也是可以的
重载overload
	overload是重载，一般是在一个类实现若干重载的方法，
	这些方法的名称相同而参数形式不同。但是不能靠返回类型来判断。
	重载需要注意：
    		位于同一个类中
    		函数的名字必须相同
    		形参列表不同
		基于成员函数是否为const，也可以重载
    	若一个重载版本的函数面前有virtual修饰，则表示他是虚函数，但他也是属于重载的一个版本
    		不同的构造函数(无参构造、有参构造、拷贝构造）是重载的应用
重定义redefining
	派生类对基类的成员函数重新定义，即派生类定义了某个函数，该函数的名字与基类中函数名字一样。
	重定义也叫做隐藏，子类重定义父类中有相同名称的非虚函数（参数可以不同）。如果一个类，
	存在和父类相同的函数，那么这个类将会覆盖其父类的方法，除非你在调用的时候，强制转换为父类类型，
		否则试图对子类和父类做类似重载的调用时不能成功的。
	重定义需要注意：
    		不在同一个作用域（分别位于基类、派生类）
    	函数的名字必须相同
    	对函数的返回值、形参列表无要求
    	若派生类定义该函数与基类的成员函数完全一样（返回值、形参列表均相同），且基类的该函数为virtual，
		则属于派生类重写基类的虚函数
    	若重新定义了基类中的一个重载函数，则在派生类中，基类中该名字函数（即其他所有重载版本）
		都会被自动隐藏，包括同名的虚函数
多态polymorphism
　　多态的概念比较复杂，一种不严谨的说法是：继承是子类使用父类的方法，而多态是父类使用子类的方法。
　　一般我们使用多态是为了避免在父类里大量重载引起代码臃肿且难于维护。
　　多态分为两类：静态多态性和动态多态性，以前学过的函数重载和运算符重载实现的多态性属于静态多态性，
	在程序编译时系统就能决定调用哪个函数，因此静态多态性又称为编译时的多态性。静态多态性是通过函数的重载实现的。
	动态多态性是在程序运行过程中才动态地确定操作所针对的对象。它又称运行时的多态性。动态多态性是通过虚函数实现的。

动态绑定：
	只有通过基类的引用或指针调用虚函数，才会发生动态绑定：即运行时绑定
常量成员函数：
	double avg_price() const;
	const 成员不能改变其所操作的对象的数据成员。const 必须同时出现在声
		明和定义中，若只出现在其中一处，就会出现一个编译时错误。
成员函数重载
	只能重载本类的其他成员函数。类的成员函数与普通的非成员函数以及在其他类中声明的函数不相关，
		也不能重载它们。
不完整类型：
	在声明之后，定义之前，是一个不完整类型，不能定义该类型的的对象，只能定义指向该类型的指针以及引用，
		或者用于声明使用该类型作为形参类型或返回类型的函数；例如定义链表类时或单例类；
this指针：
	在普通非CONST成员函数中，是一个指向类类型的const指针，在const成员函数中是一个指向
		const类类型对象的const指针；
可变数据成员：
	mutable：甚至const成员也可以修改
大小端：
	大端模式，是指数据的高字节保存在内存的低地址中，
		而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作
		字符串顺序处理：地址由小向大增加，而数据从高位往低位放；
	小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
		这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。
类成员作用域：
	不仅要考虑在本类<定义>之前的全局作用域中的[声明]，而且要考虑在成员函数<定义>之前出现的全局作用域[声明]。
初始化：
	在局部作用域中这些成员不被初始化，在全局作用域中他们被初始化为0；
初始化列表：
	没有默认构造函数的类类型的成员，以及const或引用类型的成员<只能初始化，不能复制>，
	不管是哪种类型，都必须在构造函数初始化列表中进行初始化;
初始化次序：
	就是定义成员的次序，不是初始化列表中的次序。
显式初始化：==不建议
	对于没有定义构造函数并且其全体数据均为public的类，可以采用与初始化数组元素相同的方式初始化
	其成员。
explicit:
	抑制由构造函数定义的隐式转换；只能用在类内部的构造函数声明上。外部定义时不再重复它。
	除非有明显理由要定义隐式转换，否则单形参构造函数应该定义为explicit，若有转换需要，还可以
	显式使用构造函数来转换。
静态成员：
	外部定义时，无需重复指定static保留字，该保留字只出现在声明处；
	static函数没有this指针；
		因为static成员是类的组成部分但不是任何对象的组成部分，所以也不能被声明为const；，
		也不能被声明为虚函数；
	static数据成员必须在类定义体的外部定义正好一次；他不是通过类构造函数进行初始化，
		而应该在定义时进行初始化；
		-- 类的数据成员不能在类定义体中初始化，例外：只要初始化式是一个常量表达式，
		-- 整形const static数据成员就可以在类的定义体中进行初始化，const static数据成员
		-- 在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义，
			若在类内部提供初始化式时，成员的定义不必再指定初始值；
		-- const static数据成员的类型可以是该成员所属的类类型。
		-- const static数据成员可用作默认实参
复制构造函数：
	具有单个形参，该形参(常用const修饰)是对该类类型的引用。
	・显式使用：当定义一个新对象并用一个同类型的对象对它进行初始化时。
	・隐式使用：当将该类型的对象传递给函数或函数返回该对象类型的对象时。
	直接初始化：将初始化式放在圆括号中。-》直接调用实参匹配的构造函数。
	复制初始化：使用=符号。-》创建临时对象――》复制到正在创建的对象
	-- 型参与返回值：为类类型时，使用复制构造函数进行复制
	-- 初始化容器元素：-》默认构造创建临时值-》复制构造复制到每一个元素
	-- 数组元素：若没有提供类类型的元素初始化，则默认构造初始化每个元素。
		若使用花括号初始化列表，则先创建后复制。
	禁止复制：将复制构造函数声明为private，类的友元和成员仍可复制，声明但不定义则绝不能复制。
	若定义了复制构造函数，也必须定义默认构造函数
赋值操作符：
	重载operate=函数，可以对赋值进行定义。
	-- 为类成员时，第一个操作数隐式绑定到this指针，右操作数一般为const引用传递。
	-- 返回值一般为类引用。
	复制构造函数和赋值操作符应一起出现。
析构函数：
	逆序撤销每个非static成员。
	即使我们编写了自己的析构函数，合成析构函数仍然运行。
	动态分配的对象只有在指向该对象的指针被删除时才撤销。
	当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的
	-- 指针或实际对象超出作用域时，才会运行析构函数。
	--容器中的对象逆序析构。
	三法则:如果类需要析构函数，则应该也需要复制构造函数和赋值操作符。
指针成员：
	复制指针时只复制指针中的地址，而不会复制指针指向的对象。
	管理指针常用的三种方法：
	1.指针成员采取常规指针性行为。这样的类具有指针的所有缺陷但无需特殊的复制控制。
	2.类可以实现所谓的智能指针行为。所指对象共享，但类能够防止悬垂指针。
	3.类采取值型行为。指针所指对象唯一，由每个类对象独立管理。复制时得到新副本，例如String类。
重载操作符：
	必须具有至少一个类类型或枚举类型的操作数。
	除了函数调用操作符operator()之外，重载操作符时使用默认实参是非法的。
	复合赋值(+=)返回对左操作数的引用，加操作符返回一个对象(为与内置操作符保持一致)。
	赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）等操作符必
	-- 须定义为成员，将这些操作符定义为非成员函数将在编译时标记为错误。
	? 像赋值一样，复合赋值操作符通常应定义为类的成员，与赋值不同的是，
	-- 不一定非得这样做， 如果定义非成员复合赋值操作符， 不会出现编译错误。
	? 改变对象状态或与给定类型紧密联系的其他一些操作符，如自增、自减和
	-- 解引用，通常就定义为类成员。
	? 对称的操作符，如算术操作符、相等操作符、关系操作符和位操作符，最
	-- 好定义为普通非成员函数。
	输出操作符不应该输出换行符。
	IO操作符必须为非成员函数：
		否则，左操作数只能是该类类型的对象，例：item<<cout;
		通常设置为友元。
	要输出的参数常设置为const引用。
	要输入的参数必须为非const，因为要读到该对象中。
		输入操作符必须处理错误和文件结束的可能性。if(cin) .. else 复位(默认构造)；
	赋值操作符可以重载，必须定义为成员函数，必须返回对*this的引用。	
	下标操作符定义时，一般需要两个版本：一个为非const成员并返回引用，一个为const成员返回
		const引用。
	自增/自减运算符：
		后缀式操作符函数接受一个额外的int型形参。
	函数调用操作符：
		boo operator(const string&s){return s.size()>=this->size}
		必须声明为成员函数。可重载。定义此的对象称为函数对象。
		函数对象的函数适配器：
			绑定器：将一个操作数绑定给定值而将二元函数对象转换为一元函数对象。
				bind1st和bind2nd：例：count_if(v.begin(),v.end(),
										bind2nd(less_equal<int>(),10);
			求反器：将谓词函数对象的真值求反。
				not1和not2：not1将一元函数对象的真值求反，not2将二元函数对象的真值求反。
				例：count_if(v.begin(),v.end(),
								not1(bind2nd(less_equal<int>(),10);
类类型转换：
	转换操作符：
		operator type() [const];//常为const成员
		必须为成员函数，不能指定返回类型，形参表必须为空。必须显式返回一个指定类型的值。
		只能应用一个类类型转换。
面向对象基本概念：数据抽象、继承、动态绑定
	虚函数：基类希望派生类重写的函数应定义为virtual，希望被继承的函数不能被定义为虚函数。
			非static成员函数。
			派生类必须对想要重定义的每个继承成员进行声明。
			声明必须与基类中的定义方式完全匹配，一个例外：返回对基类的引用或指针的虚函数，
				派生类中的虚函数可以返回基类函数所返回类型的派生类的引用或指针。
			加上域操作符可以强制调用虚函数的特定版本。
			派生类虚函数调用基类版本时，必须显式使用作用域操作符，否则，
				函数调用会在运行时确定并且是一个自身调用，导致无穷递归。
	动态绑定：使用继承层次中的任意对象，运行时指定，通过基类的引用或指针调用虚函数时发生。
			使用条件：1.只有虚函数成员才能进行动态绑定。
					2.必须通过基类类型的引用或指针进行函数调用。	
	protected成员：派生类只能通过派生类对象访问其基类的protected成员，派生类对
			其基类类型对象的protected成员没有特殊访问权限。
	派生类可以进一步限制基类的访问权限，但不能放松权限，无论什么访问标号，直接派生类
		对基类成员有相同的访问权限。派生类访问标号控制派生类的用户对从基类继承而来
		的成员的访问。
	友元关系不能继承。
转换与继承：
	转换要考虑派生列表中的访问标号。
	派生类对象转换为基类类型的引用：
		派生类对象的地址可以对基类类型的指针进行赋值或者初始化。
		可以使用派生类类型的引用或对象初始化基类类型的引用。
	派生类对象对基类对象进行初始化或赋值：
		将派生类传给希望接受基类类型对象的函数时，派生类的基类部分被复制到形参。
派生类构造函数：
	合成的派生类默认构造函数：
		1.调用基类的默认构造函数，初始化基类部分
		2.用常规变量初始化派生类部分，即未初始化。
	派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继
		承成员。相反派生类构造函数通过将基类包含在构造函数初始化列表中来间接初
		始化继承成员。
继承与复制：
	只含有类类型或内置类型数据成员、不含指针的类一般可以使用合成操作，
	具有指针成员的类一般需要定义自己的复制控制来管理这些成员。
	如果派生类定义了自己的复制构造函数，该复制构造函数一般显式使用基类复制构造
		函数初始化对象的基类部分。
	派生类赋值操作符同上：
		且赋值操作符必须防止自身复制：if(this!=&rhs){再操作};
	派生类析构函数;
		不负责撤销基类部分的成员，编译器显式调用派生类对象基类部分的析构函数。
		首先运行派生类析构函数，再运行基类析构函数。
虚析构函数：
	处理继承层次中的对象时，指针的静态类型可能与被删除对象的动态
		类型不同，可能会删除实际指向派生类对象的基类类型指针。
		解释:如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象
			实际是派生类类型，则没有定义该行为。所以析构函数必须是虚函数。
			例：class A;class B:public A; A * p=new B();
构造函数和析构函数中的虚函数问题：
	派生类构造过程中和派生类析构过程中，对象是不完整的。编译器将对象的类型视为
		在此期间发生了变化，将派生类对象当作基类类型对象对待。
		如果在析构函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数
			自身类型定义的版本。
	



















