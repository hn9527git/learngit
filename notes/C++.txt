重写（覆盖）override
	override是重写（覆盖）了一个方法，以实现不同的功能。一般用于子类在继承父类时，重写（覆盖）
		父类中的方法。函数特征相同，但是具体实现不同。
	重写需要注意：
		被重写的函数不能是static的，必须是virtual的
		重写函数必须有相同的类型，名称和参数列表
		重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public、protect也是可以的
重载overload
	overload是重载，一般是在一个类实现若干重载的方法，
	这些方法的名称相同而参数形式不同。但是不能靠返回类型来判断。
	重载需要注意：
    		位于同一个类中
    		函数的名字必须相同
    		形参列表不同
		基于成员函数是否为const，也可以重载
    	若一个重载版本的函数面前有virtual修饰，则表示他是虚函数，但他也是属于重载的一个版本
    		不同的构造函数(无参构造、有参构造、拷贝构造）是重载的应用
重定义redefining
	派生类对基类的成员函数重新定义，即派生类定义了某个函数，该函数的名字与基类中函数名字一样。
	重定义也叫做隐藏，子类重定义父类中有相同名称的非虚函数（参数可以不同）。如果一个类，
	存在和父类相同的函数，那么这个类将会覆盖其父类的方法，除非你在调用的时候，强制转换为父类类型，
		否则试图对子类和父类做类似重载的调用时不能成功的。
	重定义需要注意：
    		不在同一个作用域（分别位于基类、派生类）
    	函数的名字必须相同
    	对函数的返回值、形参列表无要求
    	若派生类定义该函数与基类的成员函数完全一样（返回值、形参列表均相同），且基类的该函数为virtual，
		则属于派生类重写基类的虚函数
    	若重新定义了基类中的一个重载函数，则在派生类中，基类中该名字函数（即其他所有重载版本）
		都会被自动隐藏，包括同名的虚函数
多态polymorphism
　　多态的概念比较复杂，一种不严谨的说法是：继承是子类使用父类的方法，而多态是父类使用子类的方法。
　　一般我们使用多态是为了避免在父类里大量重载引起代码臃肿且难于维护。
　　多态分为两类：静态多态性和动态多态性，以前学过的函数重载和运算符重载实现的多态性属于静态多态性，
	在程序编译时系统就能决定调用哪个函数，因此静态多态性又称为编译时的多态性。静态多态性是通过函数的重载实现的。
	动态多态性是在程序运行过程中才动态地确定操作所针对的对象。它又称运行时的多态性。动态多态性是通过虚函数实现的。

动态绑定：
	只有通过基类的引用或指针调用虚函数，才会发生动态绑定：即运行时绑定
常量成员函数：
	double avg_price() const;
	const 成员不能改变其所操作的对象的数据成员。const 必须同时出现在声
		明和定义中，若只出现在其中一处，就会出现一个编译时错误。
成员函数重载
	只能重载本类的其他成员函数。类的成员函数与普通的非成员函数以及在其他类中声明的函数不相关，
		也不能重载它们。
不完整类型：
	在声明之后，定义之前，是一个不完整类型，不能定义该类型的的对象，只能定义指向该类型的指针以及引用，
		或者用于声明使用该类型作为形参类型或返回类型的函数；例如定义链表类时或单例类；
this指针：
	在普通非CONST成员函数中，是一个指向类类型的const指针，在const成员函数中是一个指向
		const类类型对象的const指针；
可变数据成员：
	mutable：甚至const成员也可以修改
大小端：
	大端模式，是指数据的高字节保存在内存的低地址中，
		而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作
		字符串顺序处理：地址由小向大增加，而数据从高位往低位放；
	小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
		这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。
类成员作用域：
	不仅要考虑在本类<定义>之前的全局作用域中的[声明]，而且要考虑在成员函数<定义>之前出现的全局作用域[声明]。
初始化：
	在局部作用域中这些成员不被初始化，在全局作用域中他们被初始化为0；
初始化列表：
	没有默认构造函数的类类型的成员，以及const或引用类型的成员<只能初始化，不能复制>，
	不管是哪种类型，都必须在构造函数初始化列表中进行初始化;
初始化次序：
	就是定义成员的次序，不是初始化列表中的次序。
显式初始化：==不建议
	对于没有定义构造函数并且其全体数据均为public的类，可以采用与初始化数组元素相同的方式初始化
	其成员。
explicit:
	抑制由构造函数定义的隐式转换；只能用在类内部的构造函数声明上。外部定义时不再重复它。
	除非有明显理由要定义隐式转换，否则单形参构造函数应该定义为explicit，若有转换需要，还可以
	显式使用构造函数来转换。
静态成员：
	外部定义时，无需重复指定static保留字，该保留字只出现在声明处；
	static函数没有this指针；
		因为static成员是类的组成部分但不是任何对象的组成部分，所以也不能被声明为const；，
		也不能被声明为虚函数；
	static数据成员必须在类定义体的外部定义正好一次；他不是通过类构造函数进行初始化，
		而应该在定义时进行初始化；
		-- 类的数据成员不能在类定义体中初始化，例外：只要初始化式是一个常量表达式，
		-- 整形const static数据成员就可以在类的定义体中进行初始化，const static数据成员
		-- 在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义，
			若在类内部提供初始化式时，成员的定义不必再指定初始值；
		-- const static数据成员的类型可以是该成员所属的类类型。
		-- const static数据成员可用作默认实参
		
		
	




















